#!/usr/bin/env node --stack_size=800 -r ts-node/register

import { readFileSync, writeFileSync } from 'node:fs';
import path from 'node:path';
import { Project, type SourceFile } from 'ts-morph';

// Get target package from command line argument
const targetPackage = process.argv[2];
if (!targetPackage) {
  console.error('Usage: ./generate/reExportEverything.ts <package-name>');
  console.error('Example: ./generate/reExportEverything.ts cma-client-node');
  process.exit(1);
}

const SRC_FILE = path.resolve(
  __dirname,
  `../packages/${targetPackage}/src/index.ts`,
);
const CMA_CLIENT_PATH = path.resolve(
  __dirname,
  '../packages/cma-client/dist/types/index.d.ts',
);

const START_MARKER = '// <AUTO-GENERATED-EXPORTS>';
const END_MARKER = '// </AUTO-GENERATED-EXPORTS>';

const blacklist = new Set([
  'buildClient',
  'Client',
  'GenericClient',
  'Resources',
  'default',
]);

const project = new Project({
  compilerOptions: {
    moduleResolution: 2, // Node
    target: 99, // ESNext
  },
});

// Track collected exports
const collected = {
  value: new Set<string>(),
  type: new Set<string>(),
};

// Avoid infinite recursion
const visitedFiles = new Set<string>();

function collectExports(file: SourceFile) {
  if (visitedFiles.has(file.getFilePath())) return;
  visitedFiles.add(file.getFilePath());

  for (const stmt of file.getExportDeclarations()) {
    const moduleSpecifier = stmt.getModuleSpecifierSourceFile();

    // Handle named exports
    const namedExports = stmt.getNamedExports();
    for (const ne of namedExports) {
      const name = ne.getName();
      if (blacklist.has(name)) continue;

      if (stmt.isTypeOnly()) collected.type.add(name);
      else collected.value.add(name);
    }

    // Handle export * (wildcards) - recursively collect from the target file
    // Note: export * statements have 0 named exports and no namespace export identifier
    const isWildcard =
      stmt.getNamedExports().length === 0 && !stmt.getNamespaceExport();

    if (isWildcard && moduleSpecifier) {
      // Case 1: moduleSpecifier is resolved by ts-morph
      collectExports(moduleSpecifier);
    } else if (isWildcard && stmt.getModuleSpecifier()) {
      // Case 2: relative imports that ts-morph didn't resolve
      const moduleString = stmt.getModuleSpecifier()?.getLiteralValue();
      if (moduleString) {
        // Try to resolve the module path relative to current file
        const currentDir = path.dirname(file.getFilePath());
        const resolvedPath = path.resolve(currentDir, `${moduleString}.d.ts`);

        try {
          const targetFile = project.addSourceFileAtPath(resolvedPath);
          collectExports(targetFile);
        } catch (e) {
          console.warn(
            `Could not resolve wildcard export: ${moduleString} from ${file.getFilePath()}`,
          );
        }
      }
    }

    // Handle "export * as NS" â†’ collect namespace as a value export
    const nsExport = stmt.getNamespaceExport();
    if (nsExport) {
      const nsName = nsExport.getName();
      if (nsName && !blacklist.has(nsName)) {
        collected.value.add(nsName);
      }
    }
  }

  // Collect direct exports from functions, classes, variables
  for (const fn of file.getFunctions()) {
    if (fn.isExported() && !blacklist.has(fn.getName() || '')) {
      collected.value.add(fn.getName() || '');
    }
  }

  for (const cls of file.getClasses()) {
    if (cls.isExported() && !blacklist.has(cls.getName() || '')) {
      collected.value.add(cls.getName() || '');
    }
  }

  for (const vs of file.getVariableStatements()) {
    if (vs.isExported()) {
      for (const decl of vs.getDeclarations()) {
        const name = decl.getName();
        if (!blacklist.has(name)) {
          collected.value.add(name);
        }
      }
    }
  }

  // Also collect type-only exports directly declared in this file
  for (const ta of file.getTypeAliases()) {
    if (ta.isExported() && !blacklist.has(ta.getName())) {
      collected.type.add(ta.getName());
    }
  }
  for (const i of file.getInterfaces()) {
    if (i.isExported() && !blacklist.has(i.getName())) {
      collected.type.add(i.getName());
    }
  }
  for (const e of file.getEnums()) {
    if (e.isExported() && !blacklist.has(e.getName())) {
      collected.value.add(e.getName());
    }
  }
}

const cmaFile = project.addSourceFileAtPath(CMA_CLIENT_PATH);
collectExports(cmaFile);

const valueExports = Array.from(collected.value).sort();
const typeExports = Array.from(collected.type).sort();

const newExportBlock = `
${START_MARKER}
export {
  ${valueExports.join(',\n  ')},
} from '@datocms/cma-client';

export type {
  ${typeExports.join(',\n  ')},
} from '@datocms/cma-client';
${END_MARKER}
`.trim();

// Read existing file
let content = '';
try {
  content = readFileSync(SRC_FILE, 'utf-8');
} catch {
  console.warn(`File ${SRC_FILE} not found. Creating a new one.`);
}

// Replace old export block if present, otherwise prepend
if (content.includes(START_MARKER) && content.includes(END_MARKER)) {
  const regex = new RegExp(`${START_MARKER}[\\s\\S]*?${END_MARKER}`, 'm');
  content = content.replace(regex, newExportBlock);
} else {
  content = `${newExportBlock}\n\n${content}`;
}

// Write updated file
writeFileSync(SRC_FILE, content);
console.log(`Updated exports (including types) in ${SRC_FILE}`);

