#!/usr/bin/env -S node -r ts-node/register

import { readFileSync, writeFileSync } from 'node:fs';
import path from 'node:path';
import { Project, SyntaxKind, type Node } from 'ts-morph';

const repoRoot = path.resolve(__dirname, '..');

function pretty(p: string) {
  return path.relative(repoRoot, p);
}

const targetPackage = process.argv[2];
if (!targetPackage) {
  console.error('Usage: ./generate/reExportEverything.light.ts <package-name>');
  process.exit(1);
}

const SRC_FILE = path.resolve(
  __dirname,
  `../packages/${targetPackage}/src/index.ts`,
);
const TYPES_DIR = path.resolve(__dirname, '../packages/cma-client/dist/types');
const ENTRY_D_TS = path.join(TYPES_DIR, 'index.d.ts');

const START_MARKER = '// <AUTO-GENERATED-EXPORTS>';
const END_MARKER = '// </AUTO-GENERATED-EXPORTS>';

// Keep these out of the public surface:
const blacklist = new Set([
  'buildClient',
  'Client',
  'GenericClient',
  'Resources',
  'default',
]);

const project = new Project({
  compilerOptions: {
    moduleResolution: 2, // Node
    target: 99, // ESNext
  },
  skipAddingFilesFromTsConfig: true,
});

// Add all .d.ts under the types folder so re-exports resolve
project.addSourceFilesAtPaths(path.join(TYPES_DIR, '**/*.d.ts'));

const entry =
  project.getSourceFile(ENTRY_D_TS) ?? project.addSourceFileAtPath(ENTRY_D_TS);

const exported = entry.getExportedDeclarations();

// Gather explicit type-only names from the entry file
const explicitTypeOnly = new Set<string>();

for (const ed of entry.getExportDeclarations()) {
  // Whole declaration is type-only
  if (ed.isTypeOnly?.()) {
    for (const spec of ed.getNamedExports()) {
      const alias = spec.getAliasNode()?.getText();
      const name = alias ?? spec.getNameNode()?.getText() ?? spec.getName();
      if (name) explicitTypeOnly.add(name);
    }
  }
  // Per-specifier `export { type Foo, Bar }`
  for (const spec of ed.getNamedExports()) {
    if (spec.isTypeOnly?.()) {
      const alias = spec.getAliasNode()?.getText();
      const name = alias ?? spec.getNameNode()?.getText() ?? spec.getName();
      if (name) explicitTypeOnly.add(name);
    }
  }
}

// Classifiers
function isTypeOnlyDecl(n: Node): boolean {
  const k = n.getKind();
  if (
    k === SyntaxKind.InterfaceDeclaration ||
    k === SyntaxKind.TypeAliasDeclaration ||
    k === SyntaxKind.TypeParameter
  ) {
    return true;
  }
  // Ambient namespaces in d.ts
  if (
    k === SyntaxKind.ModuleDeclaration &&
    n.getSourceFile().isDeclarationFile()
  ) {
    return true;
  }
  return false;
}

function isValueDecl(n: Node): boolean {
  const k = n.getKind();
  return (
    k === SyntaxKind.EnumDeclaration ||
    k === SyntaxKind.ClassDeclaration ||
    k === SyntaxKind.FunctionDeclaration ||
    k === SyntaxKind.VariableDeclaration
  );
}

// Collect exports
const valueExports = new Set<string>();
const typeExports = new Set<string>();

for (const [name, decls] of exported) {
  if (!name || blacklist.has(name)) continue;

  // Explicit type-only hint
  if (explicitTypeOnly.has(name)) {
    typeExports.add(name);
    continue;
  }

  let hasValue = false;
  let hasType = false;

  if (!decls || decls.length === 0) {
    // Safer default: treat as type
    hasType = true;
  } else {
    for (const d of decls) {
      if (isValueDecl(d)) hasValue = true;
      else if (isTypeOnlyDecl(d)) hasType = true;
      else {
        // Ambiguous nodes → default to type
        hasType = true;
      }
    }
  }

  if (hasValue) valueExports.add(name);
  else if (hasType) typeExports.add(name);
}

// De-dupe: if something has a value, don’t also emit as type
for (const n of valueExports) typeExports.delete(n);

const values = Array.from(valueExports).sort();
const types = Array.from(typeExports).sort();

const lines: string[] = [];
lines.push(START_MARKER);
if (values.length) {
  lines.push(
    `export {\n  ${values.join(',\n  ')}\n} from '@datocms/cma-client';`,
  );
}
if (types.length) {
  lines.push(
    `export type {\n  ${types.join(',\n  ')}\n} from '@datocms/cma-client';`,
  );
}
lines.push(END_MARKER);
const newBlock = lines.join('\n');

// Read/patch target file
let content = '';
try {
  content = readFileSync(SRC_FILE, 'utf-8');
} catch {
  // NOP
}

if (content.includes(START_MARKER) && content.includes(END_MARKER)) {
  const re = new RegExp(`${START_MARKER}[\\s\\S]*?${END_MARKER}`, 'm');
  content = content.replace(re, newBlock);
} else {
  content = `${newBlock}\n\n${content}`;
}

writeFileSync(SRC_FILE, content);
